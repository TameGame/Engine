/// <reference path="../Assets/Interface.ts" />

module TameGame {
    /**
     * Represents an action on the render queue
     *
     * In its standard incarnation, TameGame takes the approach of redrawing the entire scene
     * every frame.
     *
     * TameGame buffers up rendering operations for later execution rather than executing them
     * immediately. This makes it possible to abort a rendering operation when the renderer
     * gets behind (so the framerate drops but there's no latency introduced). This also allows
     * for the game to run as a webworker. Finally, this is a mechanism to allow for a 'raw'
     * version of the engine to be produced that runs in v8 JavaScript with a native backend
     * instead of in a browser.
     */
    export interface RenderQueueItem {
        /** 
         * The Z-Index, or ordering of this item
         *
         * Rendering actions are performed from the lowest Z-Index from the highest. Rendering
         * actions that are added to a queue with equal Z-Indexes are performed in the order
         * that they arrived.
         */
        zIndex: number;
        
        /**
         * The action represented by this item
         *
         * Actions are assigned unique numbers: presently this is in Actions.ts, and there's no
         * real mechanism for adding new actions. Being able to create new drawing actions is
         * important, however, so this will be added at some later date.
         */
        action: number;
        
        /**
         * The integer values associated with this action
         */
        intValues: number[];
        
        /**
         * The floating point values associated with this action
         */
        floatValues: number[];
    }
    
    /**
     * A render queue represents a series of rendering operations, which are performed one after 
     * the other
     */
    export interface RenderQueue {
        /**
         * Adds an item to this queue
         */
        addItem(item: RenderQueueItem): RenderQueue;
        
        /**
         * Empties this render queue
         */
        clearQueue(): void;
        
        /**
         * Sends the actions in this queue to a renderer in the appropriate order
         */
        render(action: (item: RenderQueueItem) => void);
        
        /**
         * Retrieves the data to use when sending this queue via postMessage
         */
        getMessageData(): any;

        /**
         * Fills this render queue from data generated by getMessageData
         */
        fillFromMessageData(data: any);
    }
    
    /**
     * Interface implemented by objects that describe a renderer
     */
    export interface Renderer {
        /**
         * Renders a queue and performs an optional callback once finished
         */
        performRender(queue: RenderQueue, done?: () => void);
        
        /**
         * The sprite asset manager for this object
         */
        sprites: SpriteManager;
    }
    
    var nextActionId = 0;
    
    /**
     * Creates a new unique name for a render action
     */
    export function createRenderActionName() {
        ++nextActionId;
        return nextActionId.toString();
    }
    
    /**
     * Hash of functions that create the implementations of extensions to the render queue
     *
     * This is a workaround to the fact that TypeScript doens't support adding to the prototype
     * of existing classes (except for the built-in classes like Array). You should be able to
     * treat classes as open-ended like you can with interfaces but it's not possible yet. Looking
     * at the discussions I don't think anyone associated with TypeScript has ever considered that
     * you might want to do this.
     *
     * (That is, there's no way to do something like RenderQueueBase.prototype.foo = something and
     * have TypeScript do anything other than moan that 'foo is not declared in RenderQueueBase')
     *
     * A disadvantage of this approach is that extensions can't be added once the first instance
     * of the class has been created.
     */
    export var renderQueueExtensions: { [name: string]: (RenderQueue) => any; } = {};
    
    /**
     * Given a standard render queue object, mixes in the standard set of extensions
     */
    export var mixInRenderQueueExtensions = (queue: RenderQueue) => {
        Object.keys(renderQueueExtensions).forEach((extnName) => {
            queue[extnName] = renderQueueExtensions[extnName](queue);
        });
    }
}
